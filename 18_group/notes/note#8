문자열 포인터 & 구조체, 열거형



문자열 포인터

char * 변수명 = "문자열"; 으로 포인터를 이용해 문자열을 표현할 수 있다.
포인터는 문자열의 첫번째 문자를 가리킨다.
char* arr = "Hello";



배열 포인터

char * arr[3] = { "math", "english", "korean" };
문자열을 여러개 만들때 포인터를 이용해 메모리를 절약할 수 있다.

char [][8] = { "math", "english", "korean" }; 으로 선언하면
문자가 많은 문자열이 기준이 되기 때문에 \0 때문에 메모리 낭비가 발생한다.


문자열 포인터와 배열 포인터도 마찬가지로 *로 문자열을 하나씩 출력이 가능하다.




문자열 처리 함수

문자열에서 변수의 이름은 문자열이 아니라 포인터이기 때문에
문자열을 다루기 위해 string.h에 있는 라이브러리 함수를 통해 문자 비교, 복사 등이 가능하다.

size_t strlen(const char*) 문자 개수 출력
int strcmp(const char* s1, const char* s2) s1 s2 문자열 비교
char* strcpy(char* s1, const char* s2) 문자열 s1을 s2로 복사한다. 문자열의 길이는 s1이 s2보다 크거나 같아야 한다.
char* strcat(char* s1, const char* s2) 문자열 s1에 문자열 s2를 연결한다. 합친 문자열의 크기는 s1의 크기를 넘지 않아야 한다.



<문자열 포인터에 관한 고찰>



다른 포인터와 다르게 문자열 포인터는 &연산자로 주소값을 참조하지 않고,
"hello world"처럼 값을 직접 대입할 수 있다. 
그렇다면 문자열 포인터의 주소값은 무엇이고, 왜 그렇게 초기화를 할 수 있을까?

문자열 포인터는 값을 할당하는 동시에 주소값을 참조하는 방식이라고 생각했다.
예를 들어 char* arr = "hello world";라고 했을때
문자열 포인터가 가리키는 값은 첫번째 인덱스인 'h'가 되면서 "hello world"라는 것 자체가
포인터의 주소가 되어 별도의 연산자 없이도 주소 참조가 가능하다.

문자열 포인터를 선언할 때 const를 붙이지 않고 사용하니 오류가 발생하였다.
const는 문자열의 값을 바꾸지 말라고 직접적으로 알려주는 것으로 다른 타입에서도 사용될 경우 변수값을 바꿀 수 없다.
문자열 포인터는 문자를 배열로 선언할 때와 달리 컴퓨터의 ROM처럼 읽을 수 있지만 쓸 수 없는 포인터라고 생각했다.





구조체와 열거형


배열은 동일한 타입만을 선언할 수 있지만,
구조체는 서로 다른 자료형을 하나의 자료로 구조화한 자료형이다.

구조체의 정의
struct name{
    int a;
    char k;
    double num;
  };

구조체 선언1
int main(void){

strcut name st1 = { 10,a,1.0 } 

}
    
구조체는 함수처럼 main함수 외부에 struct 구조체명을 적고 brace안에 변수형 자료를 선언한 뒤
} 뒤에 ;(세미콜론)으로 정의한다.

구조체 선언은 main함수 안에서 struct name s1와 같이 선언하고 { }안에 타입에 맞는 값을 넣어 초기화 한다.


구조체 선언2
struct name{
    int a;
    char k;
    double num;
  }st1,st2;

다음과 같이 구조체 정의와 동시에 선언할 수 있다.

구조체명을 적지 않으면 선언할 때마다 구조체 정의를 적어야 하므로
구조체명을 적지 않는 것은 선호되지 않는 방법이다.



구조체 초기화

구조체 초기화는 strcut name st1 = { 10,a,1.0 } 와 같이 구조체 멤버 하나씩 초기화 하지 않고,
{ }를 통해 순서에 알맞게 초기화한다.



구조체 멤버 변수 접근

구조체명.멤버명 으로 구조체에서 각 멤버에 접근해 읽거나 쓸 수 있다.

ex) st1.name st1.address st1.age



구조체와 대입연산자

(st1과 st2는 모두 구조체)

st2=st1; //st1의 구조체 멤버 모두 st1에 대입한다.

st2.name = st1.name //st1.name을 st2.name에 대입한다.



typedef 구조체 재정의


기존에는 main함수 안에서 구조체를 선언할 때 struct 구조체명 변수명 으로 복잡한 선언을
typedef로 struct를 없앨뿐만 아니라 구조체명을 재정의하여 바꿀 수 있다.


구조체 정의
struct name{
  int a;
  char b;
  float c;
};

구조체 재정의
typedef struct name names;

구조체 선언
names st1 = {12,c,1.0};




구조체와 포인터


구조체 역시 포인터를 이용해 주소값을 참조할 수 있다.

구조체 포인터에서 멤버 변수에 접근하기 위해서 .연산자 대신 ->연산자를 활용한다.



ex)

Threedime s1 = { 1, 2, 3 }; //구조체에 double a,b,c 정의하고 typedef로 Threedime으로 재정의
Threedime* s2 = &s1;
printf("%d %d %d",s2->x,s2->y,s2->z);



구조체는 함수의 parameter나 함수의 타입처럼 사용할 수 있다.
ex)
struct ThreeDime SymOri(struct ThreeDime a)
{
a.x = -a.x;
a.y = -a.y;
a.z = -a.z;
return a;
}





<구조체에 대한 고찰>

구조체가 갖는 이점은 무엇일까? 한번 생각해보았다.
구조체 변수를 선언하나 일반적으로 선언하나 메모리의 총합은 변하지 않는다.
오히려 구조체 변수를 사용한 쪽이 더 메모리를 많이 사용할 지도 모른다.

구조체는 '코드를 작성하는 사용자로 하여금 편리하게 해 준다'라는게 내 생각이다.

예를 들어 게임 캐릭터의 체력, 공격력, 방어력 등의 변수를 관리하고 싶은데
구조체 객체를 사용하지 않으면 변수를 3개 선언하고, 캐릭터가 증가할수록
변수를 계속 선언해야 게임이 진행된다.

하지만 구조체를 정의한다면 구조체 선언으로 보다 편리하게
체력, 공격력, 방어력 등을 관리할 수 있고 멤버 변수에 관한 함수를 만듦으로써
유지,보수를 편리하게 사용할 것이다.






열거형

enum 열거형태그{열거형 상수 리스트}; 로 열거형을 정의한다.

열거형에서 각각의 상수는 0부터 순차적으로 증가한다.

ex) enum color { yellow, green, orange, blue };
 yellow 는 0 green은 1 orange는 2 blue는 3을 의미한다.


enum color { yellow, green, orange = 5, blue };

yellow는 0 green은 1로 동일하지만
orange는 5이고 blue는 그 다음 숫자인 6이다.
설정하지 않았을 때에는 자신의 인덱스이지만
orange = 5처럼 지정한 숫자가 존재하면
그 숫자 이후부터 숫자를 열거한다.
