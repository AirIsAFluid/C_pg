문자열 포인터 & 구조체, 열거형



문자열 포인터

char * 변수명 = "문자열"; 으로 포인터를 이용해 문자열을 표현할 수 있다.
포인터는 문자열의 첫번째 문자를 가리킨다.
char* arr = "Hello";



배열 포인터

char * arr[3] = { "math", "english", "korean" };
문자열을 여러개 만들때 포인터를 이용해 메모리를 절약할 수 있다.

char [][8] = { "math", "english", "korean" }; 으로 선언하면
문자가 많은 문자열이 기준이 되기 때문에 \0 때문에 메모리 낭비가 발생한다.


문자열 포인터와 배열 포인터도 마찬가지로 *로 문자열을 하나씩 출력이 가능하다.




문자열 처리 함수

문자열에서 변수의 이름은 문자열이 아니라 포인터이기 때문에
문자열을 다루기 위해 string.h에 있는 라이브러리 함수를 통해 문자 비교, 복사 등이 가능하다.

size_t strlen(const char*) 문자 개수 출력
int strcmp(const char* s1, const char* s2) s1 s2 문자열 비교
char* strcpy(char* s1, const char* s2) 문자열 s1을 s2로 복사한다. 문자열의 길이는 s1이 s2보다 크거나 같아야 한다.
char* strcat(char* s1, const char* s2) 문자열 s1에 문자열 s2를 연결한다. 합친 문자열의 크기는 s1의 크기를 넘지 않아야 한다.



<문자열 포인터에 관한 고찰>

다른 포인터와 다르게 문자열 포인터는 &연산자로 주소값을 참조하지 않고,
"hello world"처럼 값을 직접 대입할 수 있다. 
그렇다면 문자열 포인터의 주소값은 무엇이고, 왜 그렇게 초기화를 할 수 있을까?

문자열 포인터는 값을 할당하는 동시에 주소값을 참조하는 방식이라고 생각했다.
예를 들어 char* arr = "hello world";라고 했을때
문자열 포인터가 가리키는 값은 첫번째 인덱스인 'h'가 되면서 "hello world"라는 것 자체가
포인터의 주소가 되어 별도의 연산자 없이도 주소 참조가 가능하다.

문자열 포인터를 선언할 때 const를 붙이지 않고 사용하니 오류가 발생하였다.
const는 문자열의 값을 바꾸지 말라고 직접적으로 알려주는 것으로 다른 타입에서도 사용될 경우 변수값을 바꿀 수 없다.
문자열 포인터는 문자를 배열로 선언할 때와 달리 컴퓨터의 ROM처럼 읽을 수 있지만 쓸 수 없는 포인터라고 생각했다.







구조체와 열거형














