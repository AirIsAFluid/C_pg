파일처리와 매크로


C언어로 파일을 직접 입출력하려면
파일 포인터를 선언하고
stdio.h 헤더파일에 있는 함수로
파일을 열고 닫고 읽고 쓰고 할 수 있다.


파일 포인터 선언
FILE *fp;

파일오픈 함수와 예제
fopen(const char*, const char*)
첫번째 인자에 경로가 포함된 파일명을 적고
두번째 인자에 파일 모드(읽기, 쓰기 등)을 선언한다.

반환값 : 파일 포인터

EX)
fp = fopen("input.txt", "r");
fp포인터는 "input.txt"를 읽기 상태로 오픈하는 것을 의미하며
파일이 제대로 작동하면 fp 포인터는 파일을 작동하는 주소값을 가리킨다.


파일 모드는 텍스트 파일의 경우 "r","w","a" 등을 지원하며 텍스트 파일을 읽거나 쓰는 것이 가능하다.
          이진 파일의 경우 "rb","wb","ab"를 지원하며 각각 텍스트 파일의 "r","w","a"와 기능이 같다.


파일을 열었다면 fclose로 파일을 닫아야 한다.
FILE *fp;
⋮
fclose(fp);




파일 입출력 함수

파일에서도 printf scanf getchar putchar 등 파일 입출력 함수가 존재한다.
파일 포인터를 활용해서 파일의 값을 읽어 메인함수에 쓰거나, 반대로 원격으로 파일에 쓰는 것이 가능하다.


문자 입출력 함수 fgetc, fputc

fgetc(FILE*)
인자 파일포인터
반환값 char
파일에서 문자 하나를 읽어옴

fputc(char, FILE*)
인자 1 기록할 문자
인자 2 파일포인터
파일에 문자가 기록됨

문자열 입출력 함수 fgets, fputs

fgets(char *, int , FILE *);
인자 1 : 읽을 문자 배열 가리키는 포인터
인자 2 : 읽을 문자 크기
인자 3 : 파일 포인터

fputs(char *, FILE *);
인자 1 : 파일에 저장할 문자 배열을 가리키는 포인터
인자 2 : 파일 포인터



블록 입출력 함수 fread, fwrite

fread fwrite 형식
함수명(void* 포인터, 바이트 크기, 블록 수, FILE* 포인터);

fread fwrite는 블록 단위로 읽거나 쓸 수 있다.

인자 1 : 파일에서 읽거나 쓸 자료를 가리키는 포인터
인자 2 : 바이트 크기
인자 3 : 반복 횟수
인자 4 : 파일 포인터

ex)fread(&a, sizeof(int), 4, fp);
   fwirte(&b, sizeof(b), 1, fp);



형식화된 입출력 함수 fprintf, fscanf (printf, scanf의 파일 버전)

printf,scanf처럼 형식을 쓰고 맨 앞에 기록하거나 읽을 파일을 찾기 위해 파일 포인터를 인자에 추가한다.

형식
fprintf(FILE* 포인터, 변환기호, 변수 목록);
fscanf(FILE* 포인터, 변환기호, 변수 목록);

fprintf는 파일에 기록하고
fscanf는 파일에서 읽어들인 항목을 반환한다.




파일 임의 접근 

<fseek함수>

일반적인 방법으로는 파일을 처음부터 끝까지 순차적으로 접근한다.
임의의 위치에서 파일을 접근할 수도 있다.

(파일 위치 지시자)
SEEK_SET 파일처음  0
SEEK_CUR 현재위치  1
SEEK_END 파일끝    2

fseek 함수

fseek(FILE* fp, long offset, int origin);
인자 1 파일 포인터
인자 2 origin으로부터의 거리 (바이트 단위)
인자 3 파일 위치 지시자


사용법
FILE *fp;
fseek(fp, 100L, SEEK_SET); // 파일의 처음 위치에서 100바이트 이동해라
fseek(fp, 100L, SEEK_CUR); // 파일의 현재 위치에서 100바이트 이동해라 // 현재위치 : 시작위치+200바이트
fseek(fp, -100L, SEEK_END); // 파일의 끝에서 -100바이트 이동해라




<fgetpos , fsetpose 함수>

fgetpos(FILE* fp, fpos_t* pos);
인자 1 파일 포인터
인자 2 현재 파일 위치 지시자가 가리키는 위치를 저장하는 포인터 ( 현재 파일을 어디부터 읽을지 가리키는 위치를 저장)
fpos_t : 파일 위치 자료형으로 long을 재정의 한 것이다.

성공할 경우 반환값 0
실패할 경우 반환값 0이 아닌 값

fsetpos(FILE* fp, const fpos_t* pos);
인자 1 : 파일 포인터
인자 2 : 이동하고자 하는 파일 위치 지시자의 새로운 위치 ( 파일지시자를 새로운 위치로 변경 )

성공할 경우 반환값 0
실패할 경우 반환값 0이 아닌 값

fsetpos( ) 함수를 사용하려면 반드시 fgetpos( ) 함수를 통해 pos 값을 가지고 있어야 한다.







<파일 입출력에서 한글 텍스트 파일에 관한 고찰>

영어는 모든 글자가 아스키 코드로 맵핑되어 있고
abcd... 각 글자가 1바이트의 크기를 가지고 있어 
파일 임의 접근하기가 수월하다.

예를 들어 txt파일에 nicetomeetyou가 적혀있고
m부터 접근하고 싶으면 fseek(fp,6L,SEEK_SET);
으로 편리하다.


그러나 한글 안녕하세요를 메모장에 넣고
속성을 봤을때 10바이트로, 한 음절당 2바이트가 할당되는 것을 보았다.
(메모장에 따라 한 음절이 3바이트의 경우도 있다.)

나는 다음과 같이 텍스트파일을 오픈하고 파일에 한글을 쓰고
파일 임의 접근을 통해 파일의 내용을 덮어쓰기를 시도하였다.


//메인 함수에서 발췌
FILE* fp;
fp = fopen("classic.txt", "w");//파일열기

fprintf(fp,"안녕하세요");//파일에 안녕하세요 쓰기

fseek(fp, 6L, SEEK_SET);//파일 시작 지점에서 6바이트 이동

fprintf(fp, "덮어쓰기"); //이동한 지점에서 덮어쓰기 쓰기

fclose(fp);//파일 닫기


예상한 결과 안녕하덮어쓰기
실제결과 안녕하덮어쓰기

예상한 것처럼 3음절을 이동했다.



그렇다면 3L로 3바이트를 이동하면 어떻게 될까?
fseek(fp, 3L, SEEK_SET);
로 바꿔 결과를 출력해보았다.

예상결과 : 출력되지 않을 것이다.
실제결과 : 안났ㅎ杵껑?

실제로 출력 시 한글이 제대로 출력되지 않는다.


파일을 임의로 접근하려고 하려면
파일 내의 바이트 수를 제대로 파악하는 것이 우선시되어야 한다는 것을 알았다.






매크로

반복적으로 나타나는 상수나 함수를 명령 하나로 새롭게 정의
#define으로 정의를 시작한다.

매크로 상수
#define 매크로명 대체할값
대체할 값에는 리스트명, 수, 문자열 등이 올 수 있다.

#define PI 3.14 // PI는 3.14와 동일한 값을 가진다.
#define World "hello world!" //World는 "hello world"의 문자열이다.



매크로 함수
#define   매크로 함수명(인자1, 인자2, ...)   함수_정의

예시

#define Multiply(x,y) ((x)*(y))

Multiply(3,5) // 출력결과 15
