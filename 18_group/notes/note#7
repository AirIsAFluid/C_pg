포인터


포인터는 주소값을 저장하는 변수로써 type과 변수명 사이에 애스터리스크(*)를 넣어 선언한다.
ex) int* ptr; int *ptr;



일반 변수는 & 연산자를 통해 주소를 표현한다.
포인터는 변수의 주소값을 참조할 수 있다.
(포인터와 변수의 자료형은 동일해야 한다.)
ex) int a;
  int* ptr;
  ptr=&a;
(포인터 변수 ptr는 a의 주솟값을 가리킨다.)



*(단항연산자)를 이용한 포인터를 이용한 연산

포인터 앞에 *(단항연산자)를 붙여 포인터가 가리키는 주솟값에 있는 값을 바꾸거나 연산이 가능하다.
ex) int a=20;
  int* ptr=&a;
  *ptr=60;
  printf("%d",a);

출력결과 60





<Swap함수로 변수의 값이 바뀌지 않는 이유>

a : 함수에서 인자에 커서를 올려놓았을 때 지역변수라고 적혀있어.
  게다가 같은 변수명을 두 번 선언해도 프로그램이 오류가 나지 않아
  지역변수로는 메인함수 안의 변수값을 바꿀 수 없는 것 같아


b : 그것보다도 근본적인 문제가 있는 것 같아.
  
  int a=5,b=10;
  Swap(a,b)
이 프로그램과
  Swap(5,10)
의 차이점이 없는 것 같아. 결국 a=5,b=10이니까 동일한 값으로 치환되어
프로그램 내부에서 전자와 후자를 동일하게 처리해서 변수 메모리에 저장이 되지 않는 것 같아


a : 지금까지 함수를 썼을때 리턴값이 있는 int나 char를 쓰고
  반환값을 변수에 저장해서 출력했어
  void함수로 두 변수의 값을 변경하는 건 배우지 않았고
  만약 함수의 값을 바꾸고 싶다면 
  배운 방법으로는 반환값 있는 함수를 만들고
  함수를 두 번 호출해서 두 변수에 값을 저장해야 할 것 같아.


b : 값을 전달해주는 대신에 주소를 전달해서 *연산자로
  주소에 있는 값을 변경하면 원본에 있는 값이 변경될 것 같아
  잘은 모르겠지만 python에 있는 global이라는 키워드도 내부에서는 이렇게 포인터가 있지 않을까?





Call by Value

인자에 값으로 전달한다.
함수가 호출되면 Stack(LIFO)에 복사한다.
Stack은 선입후출의 메모리공간으로 나중에 호출된 것이 먼저 사라진다.
주소를 전달하는 것이 아닌 값을 복제하므로 메인함수에 있는 값에는 영향을 미치지 않고 독립적으로 수행된다.



Call by Reference

변수의 주소를 함수에 전달한다.
변수 그 자체를 전달해야 할 때 포인터를 이용하여 주소를 전달한다.
&연산자로 주소를 넘기고, *연산자로 주소가 가리키는 값을 변경하거나 설정한다.





포인터와 배열

포인터는 변수이고, 배열의 이름은 포인터 상수이다.
(배열의 이름은 상수이므로 증감연산자 사용이 불가하다)

포인터가 배열의 주솟값을 가리킬 때
ptr = &arr[0];
으로 초기화 할 수도 있지만
ptr = arr;
로 배열의 이름으로 초기화 할 수도 있다.


배열의 이름은 sizeof와 &가 없으면 
배열의 첫번째 원소를 가리키는 포인터이다.



포인터와 배열의 대응관계

배열은 실제로 메모리상에서 연속된 형태로 나타난다.
포인터의 연산은 덧셈 혹은 뺄셈에서 i만큼 더하거나 뺄 때
(자료형)*i 만큼의 주솟값 셈이 실행된다.

따라서 배열을 가리키는 포인터는 주소와 값을 여러가지 형태로 표현할 수 있다.




배열 a[10];
포인터 int* ptr = a;

배열의 주소를 표현하는 방법

          첫번째 주소        두번째 주소        세번째 주소
방법1      &a[0]            &a[1]              &a[2]

방법2      a                a+1                a+2

방법3      p                p+1                p+2



배열의 값을 표현하는 방법

            첫번째 값        두번째 값        세번째 값

방법1        a[0]            a[1]            a[2]

방법2        *a              *(a+1)          *(a+2)

방법3        *p              *(p+1)          *(p+2)

방법4        p[0]            p[1]            p[2]


a[1]은 *(a+1)로 바꿀 수 있을뿐만 아니라 1[a]로 표현할 수도 있다
그러나 가독성이 좋지 않아 권장되지는 않는다.

*p+1 != *(p+1)


포인터와 배열명에서의 증감연산자

p++ 포인터가 가리키는 곳의 다음 주소
*p++ 포인터가 가리키는 곳의 다음 주소에 들어있는 값
a++(a는 배열명) 배열명 a는 상수이므로 증감연산자로 연산이 불가능하다.
ex) a++ ( (0x7fff1e8a8d1c)++ ) 연산이 불가능하다.



배열의 합을 구하는 예제

int SumArray(int arr[],int i);

int SumArray(int* arr,int i);

두 함수는 모두 배열 안의 원소를 모두 더한 값을 출력하는 함수의 선언이다.

위의 함수는 배열 전체를 인자로 받아 메모리 낭비가 큰 반면

아래는 포인터를 이용하여 4바이트 크기의 포인터만 전달을 하면 되므로
stackoverflow에 대한 걱정을 할 필요가 거의 없다.

*연산자와 포인터의 덧셈으로 배열의 각 원소를 접근할 수 있으므로

for문으로 배열의 합을 구해서 반환할 수 있다.



(추가내용) 포인터의 증감연산자

후위 증감연산자(ptr++)는 연산을 다 처리한 후에 포인터의 값을 +1 한다.
따라서 증감연산자 단독이 아닌 대입연산자를 사용할 때에는 주의가 필요하다.

ex) int arr[3]={1,2,3};
  int* ptr = arr;
  int* k = ptr++;

printf("포인터 ptr의 주소 값에 있는 값 : %d\n",*ptr);
printf("포인터 k의 주소 값에 있는 값 : %d\n",*k);

출력 결과
포인터 ptr의 주소 값에 있는 값 : 2
포인터 k의 주소 값에 있는 값 : 1
