포인터


포인터는 주소값을 저장하는 변수로써 type과 변수명 사이에 애스터리스크(*)를 넣어 선언한다.
ex) int* ptr; int *ptr;



일반 변수는 & 연산자를 통해 주소를 표현한다.
포인터는 변수의 주소값을 참조할 수 있다.
(포인터와 변수의 자료형은 동일해야 한다.)
ex) int a;
  int* ptr;
  ptr=&a;
(포인터 변수 ptr는 a의 주솟값을 가리킨다.)



*(단항연산자)를 이용한 포인터를 이용한 연산

포인터 앞에 *(단항연산자)를 붙여 포인터가 가리키는 주솟값에 있는 값을 바꾸거나 연산이 가능하다.
ex) int a=20;
  int* ptr=&a;
  *ptr=60;
  printf("%d",a);

출력결과 60





<Swap함수로 변수의 값이 바뀌지 않는 이유>

a : 함수에서 인자에 커서를 올려놓았을 때 지역변수라고 적혀있어.
  게다가 같은 변수명을 두 번 선언해도 프로그램이 오류가 나지 않아
  지역변수로는 메인함수 안의 변수값을 바꿀 수 없는 것 같아


b : 그것보다도 근본적인 문제가 있는 것 같아.
  
  int a=5,b=10;
  Swap(a,b)
이 프로그램과
  Swap(5,10)
의 차이점이 없는 것 같아. 결국 a=5,b=10이니까 동일한 값으로 치환되어
프로그램 내부에서 전자와 후자를 동일하게 처리해서 변수 메모리에 저장이 되지 않는 것 같아


a : 지금까지 함수를 썼을때 리턴값이 있는 int나 char를 쓰고
  반환값을 변수에 저장해서 출력했어
  void함수로 두 변수의 값을 변경하는 건 배우지 않았고
  만약 함수의 값을 바꾸고 싶다면 
  배운 방법으로는 반환값 있는 함수를 만들고
  함수를 두 번 호출해서 두 변수에 값을 저장해야 할 것 같아.


b : 값을 전달해주는 대신에 주소를 전달해서 *연산자로
  주소에 있는 값을 변경하면 원본에 있는 값이 변경될 것 같아
  잘은 모르겠지만 python에 있는 global이라는 키워드도 내부에서는 이렇게 포인터가 있지 않을까?





Call by Value

인자에 값으로 전달한다.
함수가 호출되면 Stack(LIFO)에 복사한다.
Stack은 선입후출의 메모리공간으로 나중에 호출된 것이 먼저 사라진다.
주소를 전달하는 것이 아닌 값을 복제하므로 메인함수에 있는 값에는 영향을 미치지 않고 독립적으로 수행된다.



Call by Reference

변수의 주소를 함수에 전달한다.
변수 그 자체를 전달해야 할 때 포인터를 이용하여 주소를 전달한다.
&연산자로 주소를 넘기고, *연산자로 주소가 가리키는 값을 변경하거나 설정한다.




포인터와 배열

포인터는 변수이고, 배열의 이름은 포인터 상수이다.(배열의 이름은 상수이므로 증감연산자 사용이 불가하다)

포인터가 배열의 주솟값을 가리킬 때
ptr = &arr[0];
으로 초기화 할 수도 있지만
ptr = arr;
로 배열의 이름으로 초기화 할 수도 있다.


배열의 이름은 sizeof와 &가 없으면 
배열의 첫번째 원소를 가리키는 포인터이다.



포인터와 배열의 대응관계

배열은 실제로 
