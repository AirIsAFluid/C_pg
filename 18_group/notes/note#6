배열


배열은 같은 타입의 변수를 한 번에 여러 개 선언할 수 있다.
index는 0을 시작으로 n-1이 마지막이다.
ex) int array[10]; //array[0],array[1], ... array[9]

1차원 배열

배열의 초기화
int a[3] = { 1, 2, 3 }; //배열선언과 동시에 초기화
int a[] = { 1,2,3,4,5,6}; //배열의 원소 자동으로 생성
int a[4] = { 1 }; // 비어있는 원소에 0 생성  { 1, 0, 0, 0 }

틀린 예
int [];
int [4] = { 1, 2, 3, 4, 5};




236page 연습문제 8번

<대화>

a : 먼저 문제 정의를 해보자. 배열의 최댓값과 최솟값을 출력하라는 말 그대로의 문제야.
    최댓값과 최솟값을 각각 구해서 출력해보자.

b : 그러면 우선 int A[10]으로 배열을 선언과 동시에 초기화하고 for문으로 값을 비교해야겠네

a : max와 min이라는 int형 변수를 만들어서 배열 안의 값을 if문으로 비교해서 최댓값과 최솟값을 구해야겠네

b : max 와 min 값은 A[0]로 두고 for(i=1;i<10;i++)로 하면 무조건 배열 내의 숫자가 max,min값이 돼.
   if(A[i]>max) max=A[i]; if(A[i]<min) min=A[i];

a : 근데 if문 두 개가 아니라 if ~ else if문으로 처리해도 될 것 같지 않아?
    출력되는 결과도 같은데?

b : 흠... 글쎄

a : 잠시만. 아! 처음에 max와 min값을 동일한 값으로 두었으니까 max는 A[i]가 더 클 때 대입하고
   min은 더 작을 때 대입하니까 서로의 범위가 겹칠 수가 없어 그러니까 if else if로 최적화를 할 수 있어.




2차원 배열

2차원 배열은 행과 열로 이루어진 행렬과 비슷하다.

int array[2][2];

        0열        1열
0행    [0][0]    [0][1]

1행    [1][0]    [1][1]


2차원 배열의 초기화

2차원 배열은 1차원 배열과 마찬가지로 선언과 동시에 초기화 할 수 있다.

올바른 예
int array[][3] = {1,2,3,4,5,6};
int array[][3] = {1,2,3,4};

틀린 예 
int array[][] = {1,2,3,4};
int array[3][] = {1,2,3};
int array[3][];



217page 혼자해보기 7-3
<대화>

a : 나는 이중반복문을 쓰는데도 열별로 더한 값이 안 나오는데?

b : 진짜? 코드 좀 보자.

a : for(i=0;i<3;i++){
      sum=0;
      for(j=0;j<3;j++){
          sum+=num[i][j];
        }
      printf("%d열의 원소를 다 더하면 %d\n",i+1,sum);
    }

b : 일단 왜 그렇게 나오는지 말할 수 있어?

a : 123 456 789를 더해서 나왔겠지

b : 맞아 그러면 123 456 789는 각각 인덱스 [0][0] [0][1] [0][2]   [1][0] [1][1] [1][2]    [2][0] [2][1] [2][2]
   에 해당하잖아 여기서 공통된 수를 보면 행의 인덱스가 동일해 왜냐하면 for문을 머릿속으로 실행해보면서
   i=0 j=1,2,3 ...을 생각해볼수 있어. 이제 왜 틀렸는지 알겠어?

a : 그래도 모르겠는데 나머지도 설명해 줄 수 있어?

b : 그니깐 행을 기준으로 더하지말고 열을 기준으로 더할거니까 i와 j의 위치를 바꾸면 열끼리 더할 수 있어.

a : 이제 이해할 수 있을 것 같아.



문자배열

문자는 char로 1바이트로 나타낸다.
문자열은 char abc[1001];으로 선언한다.
문자는 작은 따옴표 문자열은 큰따옴표로 나타낸다.

문자열의 마지막에는 반드시 널문자가 포함되므로 입력하려는 문자열의 크기보다 1만큼 더 크게 선언해야 한다.


배열과 주소

&로 주소에 접근할 수 있다.
&A[0], &A[1], &A[2] ....
//A[0]의 주소에 접근한다. ....

배열명으로 주소 접근

A = &A[0]
A+1 = &A[1]
A+2 = &A[2]

배열의 각 원소의 주소를 출력해보면 연속된 배열의 주소값은 (자료형의 크기)*1만큼의 차이가 난다.

236page 연습문제 10번

<대화>

a : 문제 8번의 배열을 가지고 배열 A[10]의 표준편차를 만드는 프로그램을 제작하라고 되어있네

b : 일단 평균을 구한 다음에 분산을 구해서 sqrt()로 표준편차를 구하면 되겠네.

a : 평균 구하는 건 쉽지 sum=0; for(i=0;i<10;i++) sum+=A[i];
    double average = (double) sum/ i;

b : 분산도 문제에 식이 있어서 어렵지 않아
    마찬가지로 for문으로 i=0부터 9까지 원소를 평균으로 뺀 값을 제곱해서 더한뒤 그 값을 i-1(9)로 나누면 돼.

a : 자 이제 표준편차는 제곱근을 해주면 되는데 #include <math.h>헤더파일을 불러와서 pyojoon = sqrt(bunsan);하면 
    표준편차를 구할 수 있어.
    인터넷 표준편차 계산기와 값이 동일하게 나오는 것을 보니까 틀린 부분은 없어 보이네

b : math.h 헤더파일을 추가한 김에 pow(A[i]-average,2)를 사용해서 코드 길이를 줄일 수 있어.
