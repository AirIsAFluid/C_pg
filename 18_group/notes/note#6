배열


배열은 같은 타입의 변수를 한 번에 여러 개 선언할 수 있다.
index는 0을 시작으로 n-1이 마지막이다.
ex) int array[10]; //array[0],array[1], ... array[9]

1차원 배열

배열의 초기화
int a[3] = { 1, 2, 3 }; //배열선언과 동시에 초기화
int a[] = { 1,2,3,4,5,6}; //배열의 원소 자동으로 생성
int a[4] = { 1 }; // 비어있는 원소에 0 생성  { 1, 0, 0, 0 }

틀린 예
int [];
int [4] = { 1, 2, 3, 4, 5};




236page 연습문제 8번

<대화>

a : 먼저 문제 정의를 해보자. 배열의 최댓값과 최솟값을 출력하라는 말 그대로의 문제야.
    최댓값과 최솟값을 각각 구해서 출력해보자.

b : 그러면 우선 int A[10]으로 배열을 선언과 동시에 초기화하고 for문으로 값을 비교해야겠네

a : max와 min이라는 int형 변수를 만들어서 배열 안의 값을 if문으로 비교해서 최댓값과 최솟값을 구해야겠네

b : max 와 min 값은 A[0]로 두고 for(i=1;i<10;i++)로 하면 무조건 배열 내의 숫자가 max,min값이 돼.
   if(A[i]>max) max=A[i]; if(A[i]<min) min=A[i];

a : 근데 if문 두 개가 아니라 if ~ else if문으로 처리해도 될 것 같지 않아?
    출력되는 결과도 같은데?

b : 흠... 글쎄

a : 잠시만. 아! 처음에 max와 min값을 동일한 값으로 두었으니까 max는 A[i]가 더 클 때 대입하고
   min은 더 작을 때 대입하니까 서로의 범위가 겹칠 수가 없어 그러니까 if else if로 최적화를 할 수 있어.




2차원 배열

2차원 배열은 행과 열로 이루어진 행렬과 비슷하다.

int array[2][2];

        0열        1열
0행    [0][0]    [0][1]

1행    [1][0]    [1][1]


2차원 배열의 초기화

2차원 배열은 1차원 배열과 마찬가지로 선언과 동시에 초기화 할 수 있다.

올바른 예
int array[][3] = {1,2,3,4,5,6};
int array[][3] = {1,2,3,4};

틀린 예 
int array[][] = {1,2,3,4};
int array[3][] = {1,2,3};
int array[3][];



217page 혼자해보기 7-3
<대화>

a : 나는 이중반복문을 쓰는데도 열별로 더한 값이 안 나오는데?

b : 진짜? 코드 좀 보자.

a : for(i=0;i<3;i++){
      sum=0;
      for(j=0;j<3;j++){
          sum+=num[i][j];
        }
      printf("%d열의 원소를 다 더하면 %d\n",i+1,sum);
    }

b : 일단 왜 그렇게 나오는지 말할 수 있어?

a : 123 456 789를 더해서 나왔겠지

b : 맞아 그러면 123 456 789는 각각 인덱스 [0][0] [0][1] [0][2]   [1][0] [1][1] [1][2]    [2][0] [2][1] [2][2]
   에 해당하잖아 여기서 공통된 수를 보면 행의 인덱스가 동일해 왜냐하면 for문을 머릿속으로 실행해보면서
   i=0 j=1,2,3 ...을 생각해볼수 있어. 이제 왜 틀렸는지 알겠어?

a : 그래도 모르겠는데 나머지도 설명해 줄 수 있어?

b : 그니깐 행을 기준으로 더하지말고 열을 기준으로 더할거니까 i와 j의 위치를 바꾸면 열끼리 더할 수 있어.

a : 이제 이해할 수 있을 것 같아.



문자배열

문자는 char로 1바이트로 나타낸다.
문자열은 char abc[1001];으로 선언한다.
문자는 작은 따옴표 문자열은 큰따옴표로 나타낸다.

문자열의 마지막에는 반드시 널문자가 포함되므로 입력하려는 문자열의 크기보다 1만큼 더 크게 선언해야 한다.


배열과 주소

&로 주소에 접근할 수 있다.
&A[0], &A[1], &A[2] ....
//A[0]의 주소에 접근한다. ....

배열명으로 주소 접근

A = &A[0]
A+1 = &A[1]
A+2 = &A[2]

배열의 각 원소의 주소를 출력해보면 연속된 배열의 주소값은 (자료형의 크기)*1만큼의 차이가 난다.

236page 연습문제 10번

<대화>

