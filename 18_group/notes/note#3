 C언어에서는 기초적인 연산을 하기 위해 연산자가 존재하고, 연산에는 연산자와 피연산자가 필요하다.
연산자에는 산술연산자, 대입연산자, 관계연산자, 논리연산자, 비트연산자, 기타연산자 등이 있다.



1. 산술연산자

산술연산자는 일반적으로 알고 있는 +-/*에 나머지를 계산하는 %가 있다.

나눗셈 연산자는 정수형 연산과 실수형 연산이 다르다.
정수형 연산은 몫이 값으로 저장되고 실수형 연산은 소수점이 나온다.
나머지연산(%)은 나누기에서 나머지만을 값으로 저장하며 프로그래밍에 많이 활용한다. 



2. 대입연산자

대입연산자에서 lvalue는 대입연산자 왼쪽에 있는 피연산자로 변수만 가능하며, 오른쪽 값을 왼쪽에 할당한다.
rvalue는 대입연산자 오른쪽에 있는 피연산자로 값,변수,수식을 넣을 수 있으며, 대입하기 전에 수식을 실행한다.



2-1. 증감연산자

증감연산자는 산술연산자 중 단항연산자로,
+-/*%는 피연산자가 2개 필요한 반면, 증감연산자는 피연산자가 1개이다.
주로 for문에서 반복할 때 증감연산자가 사용된다.

각각 변수값을 1씩 증가,감소시키는 ++와 --가 있으며,
연산자의 위치에 따라 수식의 값이 달라진다.


a++ 변수값을 수식에 적용 후 최종변수값에서 1을 더한다.
++a 변수값에 1을 더한 후 수식에 변수값을 적용한다.
a-- 변수값을 수식에 적용 후 최종변수값에서 1을 뺀다.
--a 변수값에 1을 뺀 후 수식에 변수값을 적용한다.



예제 4-2
<대화> a,b

a : 다음 프로그램 실행 결과를 예측해보자

b : 먼저 이 문제는 증감연산자의 위치에 따른 변수의 변화를 알아보는 문제야

a : 총 3개의 수식이 나와 차례대로 과정을 설명하자

b : a = 10 ,b = 20, c = 30이고 
    a = ++b, c = b++ 를 했어

a : a=++b;라서 b에 1을 더하고 그 값을 a에 할당했어
    그리고 c=b++;는 b값을 c에 할당하고 b에 1을 더해서
    
과정 : a=21,b=21 -> a=21,b=22,c=21이야

b : 다음 식은 쉬워
    c = ++a + ++b; 니까
    a에 1을 더해 a=22, b에 1을 더해 b는 23
    그리고 c는 a와 b를 더해 c=45가 나와
    
과정 : a=22,b=23 -> a=22,b=23,c=45

a : 마자막은 두 번째 수식과 비교하여 다른 점을 찾는 것 같아
    c = a++ + b++;는 먼저 a와 b의 값을 더해 c에 대입하고
    a와 b 각각 1을 더하면 될 것 같아

과정 : c=45 -> a=23,b=24,c=45

<대화 끝>


3.관계연산자

관계연산자는 <,>,!=,== 등이 있으며 두 수 사이의 관계를 파악할 때 쓰는 연산자이다.
관계가 성립하면 참(1) 아니면 거짓(0)으로 표시한다.



4.논리연산자

2개 이상의 조건을 결합하여 판정한다.
AND OR NOT의 연산을 수행한다.

AND는 X,Y 모두 참이면 1 아니면 0의 결과를 보인다.
OR는 X,Y 중 적어도 하나가 1이면 1 아니면 0의 결과를 보인다.
NOT은 1이면 0, 0이면 1의 결과를 보인다.


X		Y		AND		OR		NOT(X)
1		1		1		1		0
1		0		0		1		0
0		1		0		1		1
0		0		0		0		1


각각 &&,||,!으로 계산하며
연산자 우선순위는 !(NOT),&&(AND),||(OR)순이다.

연산자를 섞어 쓸 때 연산자 우선순위를 알더라도 괄호를 사용하는 것이 더 좋다.



5.비트연산자


비트연산자는 피연산자 정수값을 비트단위로 논리 연산을 수행한다.
논리연산자와 달리 &,|를 하나만 쓴다.

AND &
OR |
XOR ^
NOT ~ (1의 보수)
shift >>, <<


4비트 숫자 비트연산

4 & 11		4 | 11

0100		0100
1011		1011
----		----
0000		1111

0           15



예제 4-9

<대화> a,b

a : 이 프로그램이 어떻게 돌아가는지 알겠어?

b : 응, 2의 배수를 활용하여 비트연산을 통해 해당 비트가 1인지 아닌지를 확인하는 프로그램이야

a : 맞아! 2^7과 2^0 비트가 1인지 0인지 판별하는 프로그램이야.
    입력값에 25를 집어넣으니까 25는 2진수로 00011001니까
    firstmask = 0, lastmask = 1로 결과값이 나와.

b : 근데 unsigned char에 128이상의 수를 넣으니 오류가 발생해

            (교수님의 설명을 들은 후)

a : signed char 는 %hhd, unsigned char 는 %hhu를 쓰거나,
    unsigned char를 int로 바꿔 런타임 에러를 일으키지 않을 수도 있어

b : firstmask를 %d로 출력받으니 firstmask가 1인 160을 입력할 때 128로 출력이 되네.
    firstmask가 1 또는 0으로 출력되려면 어떻게 해야 할까?

a : 그럼 각각 생각해보고 의견을 서로 말하자.

            (충분한 시간 후)

a : 출력 결과가 128 또는 0으로 나오니까 출력값을 firstmask(128)로 나누면 1 또는 0으로 나와
    printf("입력한 값 %d의 첫 번째 비트는 %d이다.\n", input, (input & firstmask) / firstmask );

b : 나는 관계연산자의 참,거짓의 값이 1 과 0이라는 것에 아이디어를 얻어
    (input & firstmask) 을 0과 비교하여 크면 참, 아니면 거짓으로 표현했어.
    printf("입력한 값 %d의 첫 번째 비트는 %d이다.\n", input, (input & firstmask) > 0 );

a : 아이디어 좋다. input를 firstmask와 & 비트연산해서 나오는 값이 128 또는 0이니까
    참이면 1이 되고 거짓이면 0이니 1, 0이 나오네

<대화 끝>


(shift 연산)

shift 연산은 << 와 >> 이 있으며
<< 연산은 왼쪽으로 비트를 옮겨 값을 증가시키고
>> 연산은 오른쪽으로 비트를 옮겨 값을 감소시킨다.




6. 기타연산자

(콤마연산자)

콤마연산자는 수식 2개를 1문장으로 표현할 때 사용한다.
우선순위가 가장 낮고, 마지막 값을 반환한다.



예제 4-12

<대화> a,b

a : 콤마의 우선순위가 낮으니 괄호를 먼저 계산해서 y에 5를 할당하고,
    y+10을 x에 할당하니까 y=5,x=15야

b : 당연한 결과라고 생각해. 만약 x = (y=5, y+10)가 아니라
    x = (y=5, y=30) 이면 컴파일이 될까?

a : x=30 y=30으로 출력될 것 같아.

b : 예상한 결과가 맞았네. 콤마연산자가 마지막값을 반환하니까
    y=30이 되고 x=30이 된 것 같아.

<대화 끝>



그 외 기타연산자에는 축약연산자(+=,-=,*=,/= 등), 
자료형의 크기를 알기 위해 사용하는 sizeof 연산자 등이 있다.







[연산자 우선 순위]

단항 > 산술 > 이동 > 관계 > 비트 > 논리 > 조건 > 대입


단향연산자가 이항연산자보다 우선순위가 높다.
산술연산자의 경우, 수학의 우선순위를 따른다.
대개 좌에서 우로 연산이 진행된다.


연산자 우선 순위를 아는 것도 중요하지만,
괄호를 사용해서 우선순위를 알아보기 쉽게 하는 것이 더 좋다.
