정렬 알고리즘


정렬 알고리즘이란 데이터를 정렬하는데 이용하는 알고리즘으로 데이터를 빠르게 정렬하기 위해 많은 연구가 이루어지고 있다.

대표적인 정렬 알고리즘으로 선택정렬, 버블정렬, 삽입정렬, 셀정렬, 퀵소트 등이 있다.



선택 정렬


선택 정렬은 가상의 벽을 움직이면서 
정렬된 리스트와 정렬되지 않은 리스트를 나누며 정렬을 시작한다.


선택 정렬 과정

1. 정렬되지 않은 리스트에서 가장 작은 원소 찾기
2. 찾은 원소의 자리를 정렬되지 않은 리스트의 첫번째 원소와 바꾼다.
3. 정렬되지 않은 리스트에서 가장 작은 값을 정렬된 리스트의 벽 앞으로 이동
4. 가상의 벽을 한 칸 움직인다.

다음 과정을 반복하여 정렬을 시도한다.

c 소스코드

void Select_Sort(int* a, int count){
  int i,j;
  int min_index,min_value;
  for(i=0;i<count-1;i++){
    min_index=i;
    min_value=a[i];
    
    for(j=i+1;j<count;j++){

        if(min_value>a[j])
        {
          min_index = j;
          min_value = a[j]
        }

      }

    a[min_index] = a[i];
    a[i] = min_value
  }

}


과정 i = 0, min_index = 0, min_value =a[0] 
      j= 1 부터 마자막 인덱스까지
      a[0]보다 a[j]가 작으면 min_index와 min_value를 바꾸면서 for문 안에 if문을 돈다.

다 돌았을 경우 a[i]와 a[min_index](정렬되지 않은 리스트의 최솟값)을 바꾼다.
(배열이 lvalue 조심)
(단, min_value = a[min_index]이므로, a[min_index] = a[i];  a[i] = min_value;)




버블 정렬



버블 정렬은 마찬가지로 정렬된 리스트와 정렬되지 않은 리스트로 나뉜다.

버블 정렬에는 두 가지 방법이 있는데, 큰 원소를 뒤로 보내는 방법(정석 방법)과 작은 원소를 맨 앞으로 정렬하는 방법이 있다.

선택 정렬과 마찬가지로 원소 앞에 가상의 벽을 세운다. 

버블 정렬 과정

1. 정렬되지 않은 리스트 뒤에서부터 원소 하나하나 비교하면서 현재보다 작으면 자리를 바꾼다. 
2. 1번을 반복하면 가장 작은 값이 맨 앞으로 온다.
3. 2번 과정으로 값을 정렬된 리스트로 넘긴다.
4. 벽을 옮겨 정렬되지 않은 리스트를 좁혀간다.

1번 정렬 원소 1개 정렬
n-1번 정렬 하면 정렬이 완료된다.

c 소스코드

void Bubble_Sort(int* a, int count)
{
  int i,j;
  int temp;
  for(i=0;i<count-1;i++)
  {
    for(j = 1;j<count-i;j++)
    {
      if(a[j-1]>a[j])
        {  
        temp=a[j-1];
        a[j-1]=a[j];
        a[j]=temp;
          }
        }
      }
  }


코드 설명

i = 0 일때 j=1부터 마지막 인덱스까지 돌면서
정렬된 리스트를 맨 뒤로 보내서 a[9]를 확정시켜놓고
다시 외부 for문으로 돌아와 i=1으로 내부 for문을 돌면서
a[8]을 확정시키는 것을 반복해서 큰 원소부터 뒤로 정렬시킨다.




삽입 정렬


가상의 벽 뒤의 원소와 앞의 원소를 비교해서
벽 뒤의 원소가 앞의 원소보다 작으면 정렬된 리스트에 삽입하는 정렬 알고리즘이다.


과정
1. 가상의 벽 바로 뒤 값을 바로 앞 값과 비교한다.
2. 벽 뒤의 값이 크면 가상의 벽을 한 칸 옮기고 1을 다시 수행한다.
3. 벽 뒤의 값이 작으면 그 값을 정렬된 리스트의 값과 뒤에서부터 비교
4. 이동하는 값보다 작은 값을 발견하면 그 값 뒤에 이동시키고 있는 원소 값을 옮긴다.
5. 벽을 한 칸 움직여 정렬 범위를 좁힌다.



c 소스코드


void Select Sort(int* a, int count)
{
  int i,j;
  int temp;

  for(i=1;i<count;i++)
  {
    temp = a[i];
    j = i;
    while((a[j-1]>temp)&&(j>0))
      {
        a[j] = a[j-1];
        j = j-1;
      }

    a[j] = temp;
  ]
}


코드 설명

temp = a[i]; 벽 뒤의 원소
벽 뒤의 원소를 벽 앞의 모든 원소와 뒤에서부터 비교한다.
(a[j-1]부터 a[0]까지 j==0 또는 a[j-1]이 temp보다 작거나 같을때까지)

ex) 4 2 8 3 5 라면
1회 반복 4|2 8 3 5 -> 4|4 8 3 5 -> 2|4 8 3 5
2회 반복 2 4|8 3 5
3회 반복 2 4 8|3 5 -> 2 4 8|8 5 -> 2 4 4|8 5 -> 2 3 4|8 5 (여기에서 3은 temp에 저장된 값 a[j]는 while문을 돌면서 수행된 a배열의 인덱스 j값)
4회 반복 2 3 4 8|5 -> 2 3 4 8|8 -> 2 3 4 5|8
5회 반복 2 3 4 5 8|



심화 정렬

셀정렬, 퀵 소트



셀정렬

삽입정렬을 응용한 정렬으로 h 간격으로 원소를 나눠 각 부분에서 삽입정렬을 시킨다.

c 소스코드

void Shell_Sort(int* a, int count)
{
  int i, j, inc, h;
  int temp;

  for(h = count/2;h>0;h/=2)
    {
      for(i =0; i<h;i++)
        {
          for(j=i+h;j<count;j+=h)
          {
            temp = a[j];
            inc = j;

            while(inc > h-1 && a[inc-h]>temp)
            { 
              a[inc] = a[inc-h];
              inc = inc - h;
            }
              a[inc] = temp;
          }  

        }
    }
}





퀵 소트

퀵 정렬은 일반적으로 알려진 빠른 정렬 방식으로 빠른 속도와 간단한 구현 방식으로 많은 사랑을 받는다.

c 소스코드


void Quick_Sort(int* a, int count)
{
  int i,j;
  int v, temp;

  if(count>1)
  {
    v = a[count-1];

    i=-1;
    j=count-1;

    for(;;)
    {
      while(a[++i]<v);
      while(a[--j]>v);

      if(i>=j) break;
      temp = a[i];
      a[i] = a[j];
      a[j] = temp;
    }
  temp = a[i];
  a[i] = a[count-1];
  a[count-1] = temp;
  Quick_Sort(a,i);
  Quick_Sort(a+i+1, count-i-1);
    
  }

}


< 정렬 알고리즘에 관한 나의 생각 >

정렬 알고리즘 아이디어 자체는 어렵지 않은 아이디어였다.
하지만 아무런 지식 없이 코드를 구현하는 것은 쉽지 않은 일이였다.
따라서 코드를 직접 짜보고 안된다면 코드를 보고 디버깅을 하면서 어떻게 알고리즘이 작동하는지 확인해야한다.

배운 정렬 알고리즘은 i,j 이중반복문과 매개변수 temp가 있는데 이 변수들이 함수에서 어떤 역할을 하는지 알아보는 것이 중요하다고 생각했다.
